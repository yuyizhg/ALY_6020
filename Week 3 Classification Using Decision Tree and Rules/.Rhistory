#These choices will allow the audience to pick and choose the districts they want to look at. The "All" button will show all districts
submitButton("Submit")
),
mainPanel(
tabsetPanel(type = 'tabs',
tabPanel("Top Crimes per UCR Type", plotOutput("hzplot", height = 700)), #Horizontal bar plot
tabPanel("Number of Crimes per District", plotOutput("bar", height = 700)), #Stacked bar plot
tabPanel("Homicides per District", plotOutput("map", height = 700)), #Map view
tabPanel("Number of Homicides each Year", plotOutput("plot", height = 700)) #Line graph
#This defines and labels each tab in the dashboard
)
)
)
)
library(shiny)
library(ggplot2)
library(maps)
library(dplyr)
#How I initially defined the crime data used
crimedat <- read.csv('Crime Incident Reports.csv')
shinyServer(function(input, output){
districtInput <- reactive({
switch(input$DISTRICT,
"A1" = crimedat[crimedat$DISTRICT == "A1",],
"A7" = crimedat[crimedat$DISTRICT == "A7",],
"A15" = crimedat[crimedat$DISTRICT == "A15",],
"B2" = crimedat[crimedat$DISTRICT == "B2",],
"B3" = crimedat[crimedat$DISTRICT =="B3",],
"C6" = crimedat[crimedat$DISTRICT == "C6",],
"C11" = crimedat[crimedat$DISTRICT == "C11",],
"D4" = crimedat[crimedat$DISTRICT == "D4",],
"D14" = crimedat[crimedat$DISTRICT == "D14",],
"E5" = crimedat[crimedat$DISTRICT == "E5",],
"E13" = crimedat[crimedat$DISTRICT == "E13",],
"E18" = crimedat[crimedat$DISTRICT == "E18",],
"All" = crimedat[,])
#This is telling the dashboard to focus only on the chosen district. The audience can choose which district to focus on using the drop-down in the dashboard
})
#Horizontal Bar Plot
output$hzplot <- renderPlot({
hz_data <- districtInput()
hz_data <- aggregate(hz_data$UCR_PART, by = list(hz_data$UCR_PART, hz_data$OFFENSE_CODE_GROUP, hz_data$DISTRICT), FUN = length)
colnames(hz_data) <- c("UCR_Group", "Offense", "District", "Count")
hz_data <- hz_data[with(hz_data, order(UCR_Group, District, -Count)),]
#The aggregate function will give the total number of rows for each type of crime grouped by each district and UCR group. I also changed the column names and ordered it by UCR group, district, and Count (descending):
#   UCR_Group                    Offense District Count
#26  Part One                    Larceny       A1  6430
#27  Part One Larceny From Motor Vehicle       A1  1607
#1   Part One         Aggravated Assault       A1  1287
#52  Part One                    Robbery       A1   820
#3   Part One                 Auto Theft       A1   459
#7   Part One        Commercial Burglary       A1   328
topfive <- hz_data %>% select(UCR_Group, District, Count, Offense) %>% group_by(UCR_Group, District) %>% slice(1:5)
topfive <- as.data.frame(topfive)
#This will return only the top five crimes per UCR group for each district:
#     UCR_Group District Count                    Offense
#  1   Part One       A1  6430                    Larceny
#  2   Part One       A1  1607 Larceny From Motor Vehicle
#  3   Part One       A1  1287         Aggravated Assault
#  4   Part One       A1   820                    Robbery
#  5   Part One       A1   459                 Auto Theft
#  6   Part One      A15   656                    Larceny
#  7   Part One      A15   380 Larceny From Motor Vehicle
#  8   Part One      A15   168         Aggravated Assault
#  9   Part One      A15   130                 Auto Theft
#  10  Part One      A15    96                    Robbery
topfive$UCR_Group <- factor(topfive$UCR_Group, levels = c("Part One", "Part Two", "Part Three")) #Ordered the levels so the legend has the order I want
g <- ggplot(topfive, aes(reorder(Offense, Count, sum), y = Count, fill = (UCR_Group))) + geom_bar( stat = 'identity') + ggtitle("Top 5 Crimes per UCR Type") + theme_classic() + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5))
g + coord_flip() + labs(x = "Offense", y = "Number of Crimes", fill = "UCR Group") +  scale_fill_manual(values = c("Part One" = 'firebrick4', "Part Two" = 'indianred2', "Part Three" = 'gray65'))
#Returns the horizontal bar plot with the specific colors chosen for each UCR group. The reorder() part of the aes code puts the bars in descending order
#This visualization highlights the top five crimes for each UCR type per district
})
#Stacked Bar Chart
output$bar <- renderPlot({
our_data <- districtInput()
our_data <- our_data[our_data$UCR_PART %in% c("Part One", "Part Two", "Part Three") & our_data$DISTRICT != "",]
#I want to only look at rows that have a valid UCR group and district
our_data <- table(our_data$UCR_PART, our_data$DISTRICT)
our_data <- our_data[c("Part One", "Part Two", "Part Three"), c("A15", "A7", "E5", "E18", "E13", "D14", "C6", "A1", "B3", "D4", "C11", "B2")]
#Used the table() function to find the number of crimes committed in each district, grouped by the UCR type. I also specified the groups and districts I wanted to look at:
#             A15    A7    E5   E18   E13   D14    C6    A1    B3    D4   C11    B2
#Part One    1557  2729  2680  3404  4674  5019  6005 11236  6757 15906  9171 11401
#Part Two    2439  5467  5137  6646  6942  7090  9512 15027 15266 15496 17863 22755
#Part Three  4621  8867  9880 13229 11753 14623 15360 21351 26015 23593 29989 33471
barplot(our_data, xlab = 'Year', ylab = 'Number of Crimes', main = "Number of Crimes Committed", col = c('firebrick4', 'indianred2', 'gray65'), ylim = c(0, 80000), legend = c("Part One", "Part Two", "Part Three"), args.legend = list(x=15, y=82000))
#Used the barplot() function to plot the table, which automatically makes it a stacked bar plot. Specified my colors and formatted my legend to make it look nice
#This visualization highlights the districts that have the most crimes (in general) and the districts that have the most Part One crimes
})
#Homicide Map View
output$map <- renderPlot({
mapdata <- districtInput()
mapdata <- mapdata[mapdata$OFFENSE_CODE_GROUP=='Homicide' & !is.na(mapdata$Lat) & mapdata$Lat>0,]
#I want my map data to only include homicide crimes so I filtered the data that way. I also took out any crime with invalid latitude/longitude points
MainStates <- map_data("state")
Massachusetts <- MainStates[MainStates$region=='massachusetts' & MainStates$subregion =='main',]
#I found all the Massachusetts latitude/longitude points I needed from the map_data in the maps package. This will outline Massachusetts in general and will be used as my map background
g <- ggplot() + geom_polygon(data = Massachusetts, aes(x=long, y=lat), fill = 'antiquewhite1') + geom_point(data = mapdata, aes(x=Long, y=Lat, colour = DISTRICT), size = 3) + ggtitle("Map of Boston") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5))
g + coord_cartesian(xlim=c(-71.20, -70.95), ylim = c(42.20, 42.40)) + labs(x='Longitude', y = 'Latitude')
#geom_polygon() is my Massachusetts map background and geom_point() has the actual homicide location points for each district. I limited the visual using coord_cartesian() so we just see the general Boston area
#This visualization highlights how most homicides occur in the central and southern districts of Boston
})
#Homicide Line Graph
output$plot <- renderPlot({
line_data <- districtInput()
line_data <- line_data[line_data$OFFENSE_CODE_GROUP=='Homicide' & line_data$YEAR != '2015' & line_data$MONTH != '12',]
#Due to missing data in 2015, and December 2019, I excluded all of 2015 and all December data (for all years)
line_data <- aggregate(line_data$YEAR, by = list(line_data$DISTRICT, line_data$YEAR), FUN = length)
colnames(line_data) <- c("District", "Year", "Count")
#The aggregate() function gives me the number of homicide crimes for each year, grouped by the District:
#  District Year Count
# 1       A1 2016     1
# 2       A7 2016     4
# 3       B2 2016    18
# 4       B3 2016    12
# 5      C11 2016    12
# 6       C6 2016     1
p <- ggplot(data = line_data, aes(x=Year, y=Count, colour=District, size = District)) + geom_line() + ggtitle("Number of Homicides per District") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4) + xlim(2016, 2019)
p + scale_color_manual(values = c("A1" = "#3399FF", "A7" = "#999999", "A15"="#999999", "B2"="#990000", "B3"="orangered1", "C6"="#999999", "C11"="goldenrod3", "D4"="#99CCFF", "D14"="#999999", "E5"="#999999", "E13"="#999999", "E18"="#999999")) + scale_size_manual(values = c("A1" = 1, "A7" = 1, "A15" = 1, "B2" = 2, "B3" = 1, "C6" = 1, "C11" = 1, "D4" = 1, "D14" = 1, "E5" = 1, "E13" = 1, "E18" = 1)) + labs(y = "Number of Homicides")
#I specified the size and color of each district to highlight district B2, which is slightly thicker in size. This district saw a huge drop in the number of homicides between 2018-2019 which I wanted to highlight
})
})
install.packages("maps")
shiny::runApp()
pwd
cwd
getwd
getwd()
shiny::runApp()
install.packages("maps")
library(maps)
shiny::runApp()
shiny::runApp()
lacerny_data
lacerny_data$MONTH
aggregate(lacerny_data$MONTH, by=lacerny_data$MONTH)
aggregate(lacerny_data$MONTH, by=lacerny_data$MONTH, FUN=length)
aggregate(lacerny_data$MONTH, by=list(lacerny_data$MONTH), FUN=length)
aggregate(lacerny_data$MONTH, by=list(lacerny_data$MONTH, lacerny_data$YEAR), FUN=length)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
filedata <- crime_data
selected <- filedata[filedata$OFFENSE_DESCRIPTION == "LARCENY THEFT FROM BUILDING", ]
agg_selected <- aggregate(selected$MONTH, by=list(selected$MONTH), FUN=length)
agg_selected
colnames(agg_selected) <- c("Month", "Count")
agg_selected
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
crime_data
crime_data[crime_data$DISTRICT == "A1"]
crime_data[crime_data$DISTRICT == "A1", ]
crime_data[crime_data$DISTRICT == "A1", crime_data$DISTRICT == "A7"]
crime_data[crime_data$DISTRICT == "A1", crime_data$DISTRICT == "A7", ]
crime_data %>%  filter(DISTRICT %in% c("A1", "A7"))
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
()
shiny::runApp()
crime_data
ttt <- crime_data[crime_data$OFFENSE_DESCRIPTION == "LARCENY THEFT FROM MV - NON-ACCESSORY", ]
ttt
ttt %>% group_by(YEAR, MONTH) %>% summarise_each(funs(mean))
ttt %>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
ttt %>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
ttt$jjj <- paste(ttt$YEAR, ttt$MONTH)
ttt
ttt %>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
tt <- ttt %>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
tt$jjj <- paste(tt$YEAR, tt$MONTH)
tt
tt$jjj
ttt <- crime_data[crime_data$OFFENSE_DESCRIPTION == "LARCENY THEFT FROM MV - NON-ACCESSORY", ]
ttt%>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
shiny::runApp()
shiny::runApp()
tt
tt
shiny::runApp()
ttt%>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
tt <- ttt%>% group_by(YEAR, MONTH) %>% summarise_each(funs(length))
tt
tt$yearmonth <- paste(tt$YEAR, tt$MONTH)
tt
tt$yearmonth
tt
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
exit
exit;
getwd()
shiny::runApp()
shiny::runApp()
pwd
exit;
quit()
quit;
shiny::runApp()
shiny::runApp()
shiny::runApp()
tt
tt$yearmonth
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
tt
tt$yearmonth
ggplot(data = tt, aes(x=yearmonth, y=Count)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4) + scale_x_discrete(breaks = c("2016 1", "2017 1", "2018 1", "2019 1", "2020 1"), labels = c("2016", "2017", "2018", "2019", "2020"))
tt$OFFENSE_CODE
ggplot(data = tt, aes(x=yearmonth, y=OFFENSE_CODE)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4) + scale_x_discrete(breaks = c("2016 1", "2017 1", "2018 1", "2019 1", "2020 1"), labels = c("2016", "2017", "2018", "2019", "2020"))
ggplot(data = tt, aes(x=yearmonth, y=OFFENSE_CODE)) + geom_line() + geom_point() + scale_x_discrete(breaks = c("2016 1", "2017 1", "2018 1", "2019 1", "2020 1"), labels = c("2016", "2017", "2018", "2019", "2020"))
tt$yearmonth <- as.numeric(paste(ttt$YEAR, ttt$MONTH))
tt
tt$yearmonth
tt$yearmonth <- as.numeric(as.character(tt$yearmonth))
tt$yearmonth
tt$yearmonth <- as.numeric(paste(ttt$YEAR, ttt$MONTH, sep = ""))
tt$yearmonth <- paste(ttt$YEAR, ttt$MONTH, sep = "")
paste(ttt$YEAR, ttt$MONTH)
paste(ttt$YEAR, ttt$MONTH, sep="")
tt$yearmonth <- paste(ttt$YEAR, ttt$MONTH)
paste(ttt$YEAR, ttt$MONTH)
as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
install.packages("zoo")
library(zoo)
as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
shiny::runApp()
shiny::runApp()
tt$yearmonth <- as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
tt$ym <- as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
ttt$ym <- as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
ttt$yearmonth <- as.yearmon(paste(ttt$YEAR, ttt$MONTH), "%Y %m")
tt <-  aggregate(ttt$yearmonth, by=list(ttt$yearmonth), FUN=length)
colnames(tt) <- c("yearmonth", "Count")
tt$yearmonth
ggplot(data = tt, aes(x=yearmonth, y=Count)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4) + scale_x_discrete(breaks = c(as.yearmon("Jan 2016"), as.yearmon("Jan 2017"), as.yearmon("Jan 2018"), as.yearmon("Jan 2019"), as.yearmon("Jan 2020")), labels = c("2016", "2017", "2018", "2019", "2020"))
})
ggplot(data = tt, aes(x=yearmonth, y=Count)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4) + scale_x_discrete(breaks = c(as.yearmon("Jan 2016"), as.yearmon("Jan 2017"), as.yearmon("Jan 2018"), as.yearmon("Jan 2019"), as.yearmon("Jan 2020")), labels = c("2016", "2017", "2018", "2019", "2020"))
ggplot(data = tt, aes(x=yearmonth, y=Count)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4))
ggplot(data = tt, aes(x=yearmonth, y=Count)) + geom_line() + ggtitle("Number of Lacerny by Month and Year") + theme(plot.title = element_text(face = 'bold')) + theme(plot.title = element_text(hjust = 0.5)) + geom_point(size = 4)
shiny::runApp()
shiny::runApp()
shiny::runApp()
install.packages('shinydashboard')
library(shinydashboard)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
library(rJava)
Sys.getenv()
SSys.getenv(JAVA_HOME)
Sys.getenv()
Sys.getenv(JAVA_HOME)
Sys.setenv(JAVA_HOME)="/Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/"
Sys.getenv("JAVA_HOME")
Sys.setenv(JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/")
Sys.getenv("JAVA_HOME")
detach("package:rJava", unload = TRUE)
library(rJava)
Sys.getenv("JAVA_HOME")
library(rJava)
detach("package:rJava", unload = TRUE)
library(rJava)
Sys.getenv("JAVA_HOME")
library(rJava)
detach("package:rJava", unload = TRUE)
library(rJava)
library(rJava)
Sys.getenv()
Sys.getenv()
library(rJava)
library(rJava)
library(rJava)
# Step 1 – collecting data
setwd('/Users/yuyizhang/FCR/NEU/CPS/Analytics_2018/ALY 6020_Predictive Analytics/Week 3 Classification Using Decision Tree and Rules')
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
# Step 3 – training a model on the data
library(RWeka)
mushroom_1R <- OneR(type ~ ., data = mushrooms)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom <- lapply(mushroom, as.factor)
str(mushroom)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
str(mushroom)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
mushroom_1R <- OneR(type ~ ., data = mushroom)
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
mushroom$odor <- factor(mushroom$odor,
levels = c("a", "l", "c", "y", "f", "m", "n", "p", "s"),
labels = c("almond", "anise","creosote","fishy","foul","musty","none","pungent","spicy"))
mushroom_1R
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 4 – evaluating model performance
summary(mushroom_1R)
mushroom$ordor <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
# Step 5 – improving model performance
mushroom_JRip <- JRip(type ~ ., data = mushroom)
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
mushroom$odor <- factor(mushroom$odor,
levels = c("a", "l", "c", "y", "f", "m", "n", "p", "s"),
labels = c("almond", "anise","creosote","fishy","foul","musty","none","pungent","spicy"))
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 4 – evaluating model performance
mushroom <- lapply(mushroom, as.factor)
summary(mushroom_1R)
# Step 5 – improving model performance
mushroom_JRip <- JRip(type ~ ., data = mushroom)
mushroom_JRip
summary(mushroom_JRip)
# Step 1 – collecting data
setwd('/Users/yuyizhang/FCR/NEU/CPS/Analytics_2018/ALY 6020_Predictive Analytics/Week 3 Classification Using Decision Tree and Rules')
# Step 2 – exploring and preparing the data
credit <- read.csv('credit.csv')
str(credit)
table(credit$Status.of.existing.checking.account)
table(credit$Savings.account.bonds)
table(credit$Status.of.existing.checking.account)
table(credit$Savings.account.bonds)
summary(credit$Duration.in.month)
summary(credit$Credit.amount)
credit$Default <- factor(credit$Default, levels = c("1", "2"), labels = c("no", "yes"))
table(credit$Default)
## Data preparation – creating random training and test datasets
set.seed(123)
train_sample <- sample(1000, 900)
str(train_sample)
credit_train <- credit[train_sample, ]
credit_test <- credit[-train_sample, ]
prop.table(table(credit_train$Default))
prop.table((table(credit_test$Default)))
# Step 3 – training a model on the data
library(C50)
credit_model <- C5.0(credit_train[-21], credit_train$Default)
credit_model
summary(credit_model)
# Step 4 – evaluating model performance
credit_pred <- predict(credit_model, credit_test)
library(gmodels)
CrossTable(credit_test$Default, credit_pred,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c('actual default', 'predicted default'))
# Step 5 – improving model performance
## Boosting the accuracy of decision trees
credit_boost10 <- C5.0(credit_train[-21], credit_train$Default,
trials = 10)
credit_boost10
summary(credit_boost10)
credit_boost10_pred10 <- predict(credit_boost10, credit_test)
CrossTable(credit_test$Default, credit_boost10_pred10,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c('actual default', 'predicted default'))
# Step 5 – improving model performance
## Boosting the accuracy of decision trees
credit_boost10 <- C5.0(credit_train[-21], credit_train$Default,
trials = 10)
credit_boost10
summary(credit_boost10)
# Step 5 – improving model performance
## Boosting the accuracy of decision trees
credit_boost10 <- C5.0(credit_train[-21], credit_train$Default,
trials = 10)
credit_boost10_pred10 <- predict(credit_boost10, credit_test)
CrossTable(credit_test$Default, credit_boost10_pred10,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c('actual default', 'predicted default'))
## Making mistakes more costlier than others
matrix_dimensions <- list(c("no", "yes"), c("no", "yes"))
names(matrix_dimensions) <- c("predicted", "actual")
error_cost <- matrix(c(0, 1, 4, 0), nrow = 2,
dimnames = matrix_dimensions)
error_cost
credit_cost <- C5.0(credit_train[-21], credit_train$Default,
costs = error_cost)
credit_cost_pred <- predict(credit_cost, credit_test)
CrossTable(credit_test$Default, credit_cost_pred,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c('actual default', 'predicted default'))
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
mushroom$odor <- factor(mushroom$odor,
levels = c("a", "l", "c", "y", "f", "m", "n", "p", "s"),
labels = c("almond", "anise", "creosote", "fishy", "foul", "musty", "none", "pungent", "spicy"))
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom$odor <- factor(mushroom$odor,
levels = c("a", "l", "c", "y", "f", "m", "n", "p", "s"),
labels = c("almond", "anise", "creosote", "fishy", "foul", "musty", "none", "pungent", "spicy"))
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 2 – exploring and preparing the data
mushroom <- read.csv('mushroom.csv')
str(mushroom)
mushroom$veil.type <- NULL
mushroom$type <- factor(mushroom$type, levels = c("e", "p"), labels = c("edible", "poisonous"))
table(mushroom$type)
mushroom$odor <- factor(mushroom$odor,
levels = c("a", "l", "c", "y", "f", "m", "n", "p", "s"),
labels = c("almond", "anise", "creosote", "fishy", "foul", "musty", "none", "pungent", "spicy"))
# Step 3 – training a model on the data
library(RWeka)
mushroom <- lapply(mushroom, as.factor)
mushroom_1R <- OneR(type ~ ., data = mushroom)
mushroom_1R
# Step 4 – evaluating model performance
summary(mushroom_1R)
# Step 5 – improving model performance
mushroom_JRip <- JRip(type ~ ., data = mushroom)
mushroom_JRip
summary(mushroom_JRip)
